#!/bin/bash

################################################################################
# Generally:
# * Each log output goes to stderrr, so that we can return value from functions
# with stdout. (Curl does the same).
################################################################################

secret_ops::program_name() {
  echo "SECRET-OPS"
}
secret_ops_program_name() {
  secret_ops::program_name
}
secret_ops::log_debug() {
  if [ "${RELEASER_LOG_LEVEL}" == "debug" ]; then
    echo -e "$(date "+%d-%m-%Y %T") $(secret_ops::program_name) debug: ${1}" >&2
  fi
}
secret_ops_log_debug() {
  secret_ops::log_debug $1
}
secret_ops::log_info() {
  echo -e "$(date "+%d-%m-%Y %T") $(secret_ops::program_name) info: ${1}" >&2
}
secret_ops_log_info() {
  secret_ops::log_info $1
}
secret_ops::log_error() {
  echo -e "\e[31m$(date "+%d-%m-%Y %T") $(secret_ops::program_name) error: $1\e[0m" >&2
  echo -e "\e[31m$(date "+%d-%m-%Y %T") $(secret_ops::program_name) error: File: ${BASH_SOURCE[0]}\e[0m" >&2
  echo -e "\e[31m$(date "+%d-%m-%Y %T") $(secret_ops::program_name) error: Line numbers: ${BASH_LINENO[*]}\e[0m" >&2
}
secret_ops_log_error() {
  secret_ops::log_error $1
}
secret_ops::log_warn() {
  echo -e "\e[33m$(date "+%d-%m-%Y %T") $(secret_ops::program_name) warn: $1\e[0m" >&2
}
secret_ops_log_warn() {
  secret_ops::log_warn $1
}

export VAULT_ADDR="${VAULT_ADDR:-https://vault.ai-traders.com:8200}"

# obsolete function
# Encrypts any string, uses GoCD server.
function encrypt_with_gocd {
  secret_ops::log_warn "Using obsolete function: encrypt_with_gocd, use encrypt_with_gocd2 instead"
  variable_to_encrypt=$1

  #FIXME: curl to go server is insecure because go uses self-signed certs
  # this token has privileges to issue ai-traders.com certificates
  my_gocd_pass=$(vault read -field=value secret/$USER/gocd)
  HTTP_RESPONSE=$(curl --silent --write-out "HTTPSTATUS:%{http_code}" \
    'https://go.ai-traders.com:8154/go/api/admin/encrypt' --insecure  \
    -u "${USER}:${my_gocd_pass}" \
    -H 'Accept: application/vnd.go.cd.v1+json' \
    -H 'Content-Type: application/json' \
    -X POST -d "{ \"value\" : \"${variable_to_encrypt}\" }")
  # extract the status
  HTTP_STATUS=$(echo $HTTP_RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
  if [ ! $HTTP_STATUS -eq 200  ]; then
    echo "Error encrypting token for gocd [HTTP status: $HTTP_STATUS]"
    exit 1
  fi
  HTTP_BODY=$(echo $HTTP_RESPONSE | sed -e 's/HTTPSTATUS\:.*//g')
  secured_value=$(echo $HTTP_BODY | jq '.encrypted_value')
}

# Encrypts any string, uses GoCD server.
function secret_ops::encrypt_with_gocd_top {
  local variable_to_encrypt=${1?variable_to_encrypt not set}

  url_dir="${USER}"
  if [[ "${USER}" == "go" ]]; then
    url_dir="gocd"
  fi
  local my_gocd_pass
  my_gocd_pass=$(vault read -field=value secret/${url_dir}/gocd_password)
  if [[ $? != "0" ]]; then exit 1; fi

  secret_ops::encrypt_with_gocd_common "${variable_to_encrypt}" "go.ai-traders.com" "-u ${USER}:${my_gocd_pass}"
}
function encrypt_with_gocd2 {
  secret_ops::encrypt_with_gocd_top $1
}
function secret_ops::encrypt_with_gocd_base {
  local variable_to_encrypt=${1?variable_to_encrypt not set}
  secret_ops::encrypt_with_gocd_common "${variable_to_encrypt}" "go2.ai-traders.com" ""
}
function encrypt_with_gocd_base {
  secret_ops::encrypt_with_gocd_base $1
}
function secret_ops::encrypt_with_gocd_common {
  local variable_to_encrypt=${1?variable_to_encrypt not set}
  local gocd_url=${2?gocd_url not set}
  local credentials=${3?credentials not set}

  echo "Encrypting with gocd server: ${gocd_url}" >&2
  #FIXME: curl to go server is insecure because go uses self-signed certs
  # this token has privileges to issue ai-traders.com certificates
  local HTTP_RESPONSE=$(curl --silent --write-out "HTTPSTATUS:%{http_code}" \
    "https://${gocd_url}:8154/go/api/admin/encrypt" --insecure ${credentials} \
    -H 'Accept: application/vnd.go.cd.v1+json' \
    -H 'Content-Type: application/json' \
    -X POST -d "{ \"value\" : \"${variable_to_encrypt}\" }")
  # extract the status
  local HTTP_STATUS=$(echo $HTTP_RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
  if [ ! $HTTP_STATUS -eq 200  ]; then
    echo "Error encrypting token for gocd [HTTP status: $HTTP_STATUS]" >&2
    exit 1
  fi
  local HTTP_BODY=$(echo $HTTP_RESPONSE | sed -e 's/HTTPSTATUS\:.*//g')
  echo $HTTP_BODY | jq '.encrypted_value'
}
function encrypt_with_gocd_common {
  secret_ops::encrypt_with_gocd_common $1 $2 $3
}

# Encrypts Vault Token.
function secret_ops::generate_certs_token {
  secret_ops::log_warn "Using obsolete function: generate_certs_token, use generate_certs_token2 instead"
  vault_token=$(vault token create -policy=issue-ait-certs -field token)
  encrypt_with_gocd "${vault_token}"
  secured_token_gocd=${secured_value}
  echo "Generated token and secured for gocd"
}
function generate_certs_token {
  secret_ops::generate_certs_token
}

# Encrypts Vault Token.
function secret_ops::generate_certs_token_gocd_top {
  local vault_token=$(vault token create -policy=issue-ait-certs -field token)
  local secured_token_gocd=$(secret_ops::encrypt_with_gocd_top "${vault_token}")
  echo "Generated token and secured for gocd" >&2
  echo "${secured_token_gocd}"
}
function generate_certs_token2 {
  secret_ops::generate_certs_token_gocd_top
}

function insert_vault_token_gocd_yaml {
  secret_ops::log_warn "Using obsolete function: insert_vault_token_gocd_yaml, use insert_vault_token_gocd_yaml2 instead"
  echo "Replacing pipeline config with with VAULT_TOKEN: ${secured_token_gocd}"
  find . -name '*.gocd.yaml' -exec sed -i -E "s#VAULT_TOKEN\:.*#VAULT_TOKEN: ${secured_token_gocd}#g" {} \;
}

function secret_ops::insert_vault_token_gocd_yaml {
  local secured_token_gocd=${1?secured_token_gocd not set}

  echo "Replacing pipeline config with with VAULT_TOKEN: ${secured_token_gocd}"
  find . -name '*.gocd.yaml' -exec sed -i -E "s#VAULT_TOKEN\:.*#VAULT_TOKEN: ${secured_token_gocd}#g" {} \;
}
function insert_vault_token_gocd_yaml2 {
  secret_ops::insert_vault_token_gocd_yaml  $1
}
