#!/bin/bash

################################################################################
# Generally:
# * Each log output goes to stderrr, so that we can return value from functions
# with stdout. (Curl does the same).
################################################################################

secret_ops::program_name() {
  echo "SECRET-OPS"
}
secret_ops::log_debug() {
  if [ "${RELEASER_LOG_LEVEL}" == "debug" ]; then
    echo -e "$(date "+%d-%m-%Y %T") $(secret_ops::program_name) debug: ${1}" >&2
  fi
}
secret_ops::log_info() {
  echo -e "$(date "+%d-%m-%Y %T") $(secret_ops::program_name) info: ${1}" >&2
}
secret_ops::log_error() {
  echo -e "\e[31m$(date "+%d-%m-%Y %T") $(secret_ops::program_name) error: $1\e[0m" >&2
  echo -e "\e[31m$(date "+%d-%m-%Y %T") $(secret_ops::program_name) error: File: ${BASH_SOURCE[0]}\e[0m" >&2
  echo -e "\e[31m$(date "+%d-%m-%Y %T") $(secret_ops::program_name) error: Line numbers: ${BASH_LINENO[*]}\e[0m" >&2
}
secret_ops::log_warn() {
  echo -e "\e[33m$(date "+%d-%m-%Y %T") $(secret_ops::program_name) warn: $1\e[0m" >&2
}

export VAULT_ADDR="${VAULT_ADDR:-https://vault.ai-traders.com:8200}"

function secret_ops::encrypt_with_gocd_common {
  local variable_to_encrypt=${1?variable_to_encrypt not set}
  local gocd_url=${2?gocd_url not set}
  local credentials=${3?credentials not set}

  echo "Encrypting with gocd server: ${gocd_url}" >&2
  #FIXME: curl to go server is insecure because go uses self-signed certs
  local HTTP_RESPONSE=$(curl --silent --write-out "HTTPSTATUS:%{http_code}" \
    "https://${gocd_url}:8154/go/api/admin/encrypt" --insecure ${credentials} \
    -H 'Accept: application/vnd.go.cd.v1+json' \
    -H 'Content-Type: application/json' \
    -X POST -d "{ \"value\" : \"${variable_to_encrypt}\" }")
  # extract the status
  local HTTP_STATUS=$(echo $HTTP_RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
  if [ ! $HTTP_STATUS -eq 200  ]; then
    echo "Error encrypting token for gocd [HTTP status: $HTTP_STATUS]" >&2
    exit 1
  fi
  local HTTP_BODY=$(echo $HTTP_RESPONSE | sed -e 's/HTTPSTATUS\:.*//g')
  echo $HTTP_BODY | jq '.encrypted_value'
}
# Encrypts any string, uses GoCD server.
function secret_ops::encrypt_with_gocd_top {
  local variable_to_encrypt=${1?variable_to_encrypt not set}
  local user=${2:-}
  url_dir=$user
  if [ -z ${user} ]; then
    user="$(whoami)"
    url_dir=$user
    if [[ "${url_dir}" == "go" ]]; then
      url_dir="gocd"
    fi
  fi
  if [ -z ${url_dir} ]; then
    echo "Unknown user name"
    exit 5
  fi
  local my_gocd_pass
  my_gocd_pass=$(vault read -field=value secret/${url_dir}/gocd_password)
  if [[ $? != "0" ]]; then exit 1; fi

  secret_ops::encrypt_with_gocd_common "${variable_to_encrypt}" "go.ai-traders.com" "-u ${user}:${my_gocd_pass}"
}
function secret_ops::encrypt_with_gocd_base {
  local variable_to_encrypt=${1?variable_to_encrypt not set}
  secret_ops::encrypt_with_gocd_common "${variable_to_encrypt}" "go2.ai-traders.com" ""
}

# Encrypts Vault Token.
function secret_ops::generate_certs_token_gocd_top {
  local vault_token=$(vault token create -policy=issue-ait-certs -field token)
  local secured_token_gocd=$(secret_ops::encrypt_with_gocd_top "${vault_token}")
  echo "Generated token and secured for gocd" >&2
  echo "${secured_token_gocd}"
}
function secret_ops::generate_certs_token2 {
  secret_ops::generate_certs_token_gocd_top
}

function secret_ops::insert_vault_token_gocd_yaml {
  local secured_token_gocd=${1?secured_token_gocd not set}

  echo "Replacing pipeline config with VAULT_TOKEN: ${secured_token_gocd}"
  find . -name '*.gocd.yaml' -exec sed -i -E "s#VAULT_TOKEN\:.*#VAULT_TOKEN: ${secured_token_gocd}#g" {} \;
}
function secret_ops::insert_vault_token_gocd_yaml2 {
  secret_ops::insert_vault_token_gocd_yaml  $1
}
